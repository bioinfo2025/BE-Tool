import re
from typing import List, Dict, Tuple


class SgRNADesigner:
    def __init__(
            self,
            pam_pattern: str = "NGG",  # PAM序列模式，N代表任意碱基
            sg_length: int = 20,  # sgRNA长度
            min_gc: float = 0.4,  # 最小GC含量
            max_gc: float = 0.6,  # 最大GC含量
            avoid_poly_t: int = 4  # 避免的连续T数量
    ):
        self.pam_pattern = pam_pattern
        self.sg_length = sg_length
        self.min_gc = min_gc
        self.max_gc = max_gc
        self.avoid_poly_t = avoid_poly_t

        # 转换PAM模式为正则表达式
        self.pam_regex = self._pam_to_regex(pam_pattern)

    def _pam_to_regex(self, pam: str) -> str:
        """将PAM序列模式转换为正则表达式"""
        base_map = {
            'N': '[ATCG]',
            'A': 'A',
            'T': 'T',
            'C': 'C',
            'G': 'G',
            'R': '[AG]',  # 嘌呤
            'Y': '[CT]',  # 嘧啶
            'S': '[GC]',  # 强键
            'W': '[AT]',  # 弱键
        }
        return ''.join(base_map.get(c, c) for c in pam)

    def _reverse_complement(self, seq: str) -> str:
        """计算DNA序列的反向互补序列"""
        complement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'}
        return ''.join(complement.get(base, base) for base in reversed(seq))

    def _calculate_gc_content(self, seq: str) -> float:
        """计算序列的GC含量"""
        if not seq:
            return 0.0
        return (seq.count('G') + seq.count('C')) / len(seq)

    def _has_poly_t(self, seq: str) -> bool:
        """检查序列中是否存在连续的T（长度>=avoid_poly_t）"""
        return re.search(f'T{{{self.avoid_poly_t},}}', seq) is not None

    def find_pam_sites(self, target_seq: str) -> List[Dict]:
        """在靶标序列中查找所有PAM位点，并提取候选sgRNA"""
        target_seq = target_seq.upper()
        candidates = []

        # 正向链查找
        for match in re.finditer(self.pam_regex, target_seq):
            pam_start = match.start()
            pam_end = match.end()

            # 计算sgRNA区域（PAM上游）
            sg_start = pam_start - self.sg_length
            sg_end = pam_start

            # 确保sgRNA区域在靶标序列内
            if sg_start >= 0:
                sg_seq = target_seq[sg_start:sg_end]
                candidates.append({
                    'sequence': sg_seq,
                    'start': sg_start,
                    'end': sg_end,
                    'strand': '+',
                    'pam': target_seq[pam_start:pam_end],
                    'pam_start': pam_start,
                    'pam_end': pam_end
                })

        # 反向链查找
        reverse_target = self._reverse_complement(target_seq)
        for match in re.finditer(self.pam_regex, reverse_target):
            pam_start = match.start()
            pam_end = match.end()

            # 计算sgRNA区域（PAM上游）
            sg_start = pam_start - self.sg_length
            sg_end = pam_start

            # 确保sgRNA区域在靶标序列内
            if sg_start >= 0:
                sg_reverse = reverse_target[sg_start:sg_end]
                sg_seq = self._reverse_complement(sg_reverse)

                # 转换为原始序列中的坐标
                original_sg_start = len(target_seq) - sg_end
                original_sg_end = len(target_seq) - sg_start
                original_pam_start = len(target_seq) - pam_end
                original_pam_end = len(target_seq) - pam_start

                candidates.append({
                    'sequence': sg_seq,
                    'start': original_sg_start,
                    'end': original_sg_end,
                    'strand': '-',
                    'pam': self._reverse_complement(reverse_target[pam_start:pam_end]),
                    'pam_start': original_pam_start,
                    'pam_end': original_pam_end
                })

        return candidates

    def filter_candidates(self, candidates: List[Dict]) -> List[Dict]:
        """过滤候选sgRNA，根据GC含量和多聚T序列"""
        filtered = []
        for candidate in candidates:
            seq = candidate['sequence']
            gc_content = self._calculate_gc_content(seq)

            # 检查GC含量
            if gc_content < self.min_gc or gc_content > self.max_gc:
                continue

            # 检查多聚T序列
            if self._has_poly_t(seq):
                continue

            # 添加评分（可扩展为更复杂的评分系统）
            candidate['gc_content'] = gc_content
            candidate['score'] = self._score_sgrna(candidate)
            filtered.append(candidate)

        return filtered

    def _score_sgrna(self, candidate: Dict) -> float:
        """对候选sgRNA进行评分（可扩展为更复杂的评分系统）"""
        # 基础评分基于GC含量（越接近50%越好）
        gc_score = 1.0 - abs(candidate['gc_content'] - 0.5) * 2

        # 可添加其他评分因素（如脱靶评分、位置评分等）
        return gc_score

    def design(self, target_seq: str) -> List[Dict]:
        """设计sgRNA的主函数"""
        # 验证输入序列
        valid_bases = set(['A', 'T', 'C', 'G'])
        if any(base not in valid_bases for base in target_seq.upper()):
            raise ValueError("Target sequence contains invalid bases. Must be A, T, C, or G.")

        # 查找PAM位点
        candidates = self.find_pam_sites(target_seq)

        # 过滤候选sgRNA
        filtered = self.filter_candidates(candidates)

        # 按评分排序
        sorted_candidates = sorted(filtered, key=lambda x: x['score'], reverse=True)

        return sorted_candidates


# 使用示例
if __name__ == "__main__":
    # 创建sgRNA设计器实例
    designer = SgRNADesigner(
        pam_pattern="NGG",  # SpCas9 PAM序列
        sg_length=20,  # sgRNA长度
        min_gc=0.4,  # 最小GC含量
        max_gc=0.6,  # 最大GC含量
        avoid_poly_t=4  # 避免连续4个T
    )
    target_sequence = "ATGGCTCTGCTTCTAGCTTCTAGCTGGTTCTAGCTTCTAGCTTCTAGGGTCTAGCTTCTAGCTTCTAGCTTCTAGCTTTTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTTCTAGCTT"

    hub = designer.design(target_sequence)
    print("设计结果（sgRNA列表）：")

    if not hub:
        print("未找到符合条件的sgRNA序列。")
    else:
        for i, sgRNA in enumerate(hub, 1):
            print(f"\nsgRNA #{i}:")

            print(f"  PAM: {sgRNA['pam']}")
            print(f"  方向: {'正向' if sgRNA['strand'] == '+' else '反向'}")
            print(f"  GC含量: {sgRNA['gc_content']:.2f}%")
            print(f"  得分: {sgRNA['score']:.2f}")


